

<directory_structure>
.gitignore
.prettierrc
eslint.config.mjs
nest-cli.json
package.json
README.md
src/app.controller.spec.ts
src/app.controller.ts
src/app.module.ts
src/app.service.ts
src/auth/auth.controller.spec.ts
src/auth/auth.controller.ts
src/auth/auth.module.ts
src/auth/auth.service.spec.ts
src/auth/auth.service.ts
src/auth/decorators/current-user.decorator.ts
src/auth/decorators/roles.decorator.ts
src/auth/dto/login.dto.ts
src/auth/dto/register.dto.ts
src/auth/guards/jwt-auth.guard.ts
src/auth/guards/roles.guard.ts
src/auth/strategies/jwt.strategy.ts
src/buses/buses.controller.ts
src/buses/buses.module.ts
src/buses/buses.service.ts
src/buses/dto/bus-owner-profile.dto.ts
src/buses/dto/create-bus.dto.ts
src/buses/dto/update-bus.dto.ts
src/main.ts
src/routes/dto/create-bus-route.dto.ts
src/routes/dto/create-route.dto.ts
src/routes/dto/update-bus-route.dto.ts
src/routes/dto/update-route.dto.ts
src/routes/routes.controller.ts
src/routes/routes.module.ts
src/routes/routes.service.ts
src/schemas/bus-owner-profile.schema.ts
src/schemas/bus-route.schema.ts
src/schemas/bus.schema.ts
src/schemas/route.schema.ts
src/schemas/user.schema.ts
test/app.e2e-spec.ts
test/jest-e2e.json
tsconfig.build.json
tsconfig.json
</directory_structure>


<file path="src/app.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});
</file>

<file path="src/app.controller.ts">
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}
</file>

<file path="src/app.service.ts">
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}
</file>

<file path="src/auth/auth.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { AuthController } from './auth.controller';

describe('AuthController', () => {
  let controller: AuthController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [AuthController],
    }).compile();

    controller = module.get<AuthController>(AuthController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
</file>

<file path="src/auth/auth.controller.ts">
import {
  Controller,
  Post,
  Body,
  Get,
  UseGuards,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import { AuthService } from './auth.service';
import { RegisterDto } from './dto/register.dto';
import { LoginDto } from './dto/login.dto';
import { JwtAuthGuard } from './guards/jwt-auth.guard';
import { CurrentUser } from './decorators/current-user.decorator';
import { UserDocument } from '../schemas/user.schema';

@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  @Post('register')
  async register(@Body() registerDto: RegisterDto) {
    return this.authService.register(registerDto);
  }

  @Post('login')
  @HttpCode(HttpStatus.OK)
  async login(@Body() loginDto: LoginDto) {
    return this.authService.login(loginDto);
  }

  @Post('logout')
  @UseGuards(JwtAuthGuard)
  async logout(@CurrentUser() user: UserDocument) {
    return this.authService.logout(user._id.toString());
  }

  @Get('profile')
  @UseGuards(JwtAuthGuard)
  async getProfile(@CurrentUser() user: UserDocument) {
    return this.authService.getProfile(user._id.toString());
  }

  @Get('me')
  @UseGuards(JwtAuthGuard)
  getCurrentUser(@CurrentUser() user: UserDocument) {
    return {
      user,
      message: 'User retrieved successfully',
    };
  }
}
</file>

<file path="src/auth/auth.module.ts">
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { MongooseModule } from '@nestjs/mongoose';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { AuthController } from './auth.controller';
import { AuthService } from './auth.service';
import { JwtStrategy } from './strategies/jwt.strategy';
import { User, UserSchema } from '../schemas/user.schema';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: User.name, schema: UserSchema }]),
    PassportModule,
    JwtModule.registerAsync({
      imports: [ConfigModule],
      useFactory: (configService: ConfigService) => ({
        secret: configService.get<string>('JWT_SECRET'),
        signOptions: {
          expiresIn: configService.get<string>('JWT_EXPIRATION'),
        },
      }),
      inject: [ConfigService],
    }),
  ],
  controllers: [AuthController],
  providers: [AuthService, JwtStrategy],
  exports: [AuthService],
})
export class AuthModule {}
</file>

<file path="src/auth/auth.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { AuthService } from './auth.service';

describe('AuthService', () => {
  let service: AuthService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [AuthService],
    }).compile();

    service = module.get<AuthService>(AuthService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/auth/auth.service.ts">
/* eslint-disable @typescript-eslint/no-unused-vars */
import {
  Injectable,
  ConflictException,
  UnauthorizedException,
  BadRequestException,
} from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { JwtService } from '@nestjs/jwt';
import { ConfigService } from '@nestjs/config';
import { Model } from 'mongoose';
import * as bcrypt from 'bcrypt';
import {
  User,
  UserDocument,
  UserStatus,
  UserRole,
} from '../schemas/user.schema';
import { RegisterDto } from './dto/register.dto';
import { LoginDto } from './dto/login.dto';

@Injectable()
export class AuthService {
  constructor(
    @InjectModel(User.name) private userModel: Model<UserDocument>,
    private jwtService: JwtService,
    private configService: ConfigService,
  ) {}

  async register(registerDto: RegisterDto) {
    const { email, password, role, profile } = registerDto;

    // Check if user already exists
    const existingUser = await this.userModel.findOne({ email });
    if (existingUser) {
      throw new ConflictException('User with this email already exists');
    }

    // Hash password
    const saltRounds = 12;
    const hashedPassword = await bcrypt.hash(password, saltRounds);

    // Create user
    const user = new this.userModel({
      email,
      password: hashedPassword,
      role,
      profile,
      status:
        role === UserRole.PASSENGER ? UserStatus.ACTIVE : UserStatus.PENDING, // Auto-approve passengers
    });

    await user.save();

    // Convert to plain object and remove password
    const userObj = user.toObject();
    const { password: _, ...userResponse } = userObj;

    return {
      message: 'User registered successfully',
      user: userResponse,
    };
  }

  async login(loginDto: LoginDto) {
    const { email, password } = loginDto;

    // Find user with password
    const user = await this.userModel.findOne({ email }).select('+password');
    if (!user) {
      throw new UnauthorizedException('Invalid credentials');
    }

    // Check password
    const isPasswordValid = await bcrypt.compare(password, user.password);
    if (!isPasswordValid) {
      throw new UnauthorizedException('Invalid credentials');
    }

    // Check if user is active
    if (user.status !== UserStatus.ACTIVE) {
      throw new UnauthorizedException(
        'Account is not active. Please contact admin.',
      );
    }

    // Generate tokens
    const tokens = await this.generateTokens(user);

    // Update refresh token in database
    const hashedRefreshToken = await bcrypt.hash(tokens.refreshToken, 10);
    await this.userModel.findByIdAndUpdate(user._id, {
      refreshToken: hashedRefreshToken,
    });

    // Convert to plain object and remove password
    const userObj = user.toObject();
    const { password: _, refreshToken: __, ...userResponse } = userObj;

    return {
      message: 'Login successful',
      user: userResponse,
      ...tokens,
    };
  }

  async logout(userId: string) {
    await this.userModel.findByIdAndUpdate(userId, {
      refreshToken: null,
    });

    return { message: 'Logout successful' };
  }

  async getProfile(userId: string) {
    const user = await this.userModel
      .findById(userId)
      .select('-password -refreshToken');
    if (!user) {
      throw new BadRequestException('User not found');
    }

    return user;
  }

  private async generateTokens(user: UserDocument) {
    const payload = {
      email: user.email,
      sub: (user._id as string | { toString(): string }).toString(),
      role: user.role,
    };

    const [accessToken, refreshToken] = await Promise.all([
      this.jwtService.signAsync(payload, {
        secret: this.configService.get<string>('JWT_SECRET'),
        expiresIn: this.configService.get<string>('JWT_EXPIRATION'),
      }),
      this.jwtService.signAsync(payload, {
        secret: this.configService.get<string>('JWT_REFRESH_SECRET'),
        expiresIn: this.configService.get<string>('JWT_REFRESH_EXPIRATION'),
      }),
    ]);

    return {
      accessToken,
      refreshToken,
    };
  }
}
</file>

<file path="src/auth/decorators/current-user.decorator.ts">
import { createParamDecorator, ExecutionContext } from '@nestjs/common';
import { Request } from 'express';
import { UserDocument } from '../../schemas/user.schema';

export const CurrentUser = createParamDecorator(
  (data: unknown, ctx: ExecutionContext): UserDocument => {
    const request = ctx.switchToHttp().getRequest<Request>();
    return request.user as UserDocument;
  },
);
</file>

<file path="src/auth/decorators/roles.decorator.ts">
import { SetMetadata } from '@nestjs/common';
import { UserRole } from '../../schemas/user.schema';

export const Roles = (...roles: UserRole[]) => SetMetadata('roles', roles);
</file>

<file path="src/auth/dto/login.dto.ts">
import { IsEmail, IsString } from 'class-validator';

export class LoginDto {
  @IsEmail()
  email: string;

  @IsString()
  password: string;
}
</file>

<file path="src/auth/dto/register.dto.ts">
import {
  IsEmail,
  IsEnum,
  IsNotEmpty,
  IsString,
  MinLength,
  ValidateNested,
  IsOptional,
  IsDateString,
} from 'class-validator';
import { Type } from 'class-transformer';
import { UserRole } from '../../schemas/user.schema';

class ProfileDto {
  @IsNotEmpty()
  @IsString()
  firstName: string;

  @IsNotEmpty()
  @IsString()
  lastName: string;

  @IsNotEmpty()
  @IsString()
  phone: string;

  @IsOptional()
  @IsDateString()
  dateOfBirth?: string;

  @IsOptional()
  @IsEnum(['male', 'female', 'other'])
  gender?: string;
}

export class RegisterDto {
  @IsEmail()
  email: string;

  @IsString()
  @MinLength(6)
  password: string;

  @IsEnum(UserRole)
  role: UserRole;

  @ValidateNested()
  @Type(() => ProfileDto)
  profile: ProfileDto;
}
</file>

<file path="src/auth/guards/jwt-auth.guard.ts">
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {}
</file>

<file path="src/auth/guards/roles.guard.ts">
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { Request } from 'express';
import { UserRole, UserDocument } from '../../schemas/user.schema';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredRoles = this.reflector.getAllAndOverride<UserRole[]>(
      'roles',
      [context.getHandler(), context.getClass()],
    );

    if (!requiredRoles) {
      return true;
    }
    const request = context.switchToHttp().getRequest<Request>();
    const user = request.user as UserDocument;

    if (!user) {
      return false;
    }

    return requiredRoles.some((role) => user.role === role);
  }
}
</file>

<file path="src/auth/strategies/jwt.strategy.ts">
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { PassportStrategy } from '@nestjs/passport';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { User, UserDocument, UserStatus } from '../../schemas/user.schema';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(
    @InjectModel(User.name) private userModel: Model<UserDocument>,
    private configService: ConfigService,
  ) {
    const jwtSecret = configService.get<string>('JWT_SECRET');
    if (!jwtSecret) {
      throw new Error('JWT_SECRET is not defined in configuration');
    }
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: jwtSecret,
    });
  }

  async validate(payload: { email: string; sub: string; role: string }) {
    const user = await this.userModel.findById(payload.sub).select('-password');

    if (!user) {
      throw new UnauthorizedException('User not found');
    }

    if (user.status !== UserStatus.ACTIVE) {
      throw new UnauthorizedException('Account is not active');
    }

    return user;
  }
}
</file>

<file path="src/buses/buses.controller.ts">
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  UseGuards,
  Query,
  ParseIntPipe,
} from '@nestjs/common';
import { BusesService } from './buses.service';
import { CreateBusDto } from './dto/create-bus.dto';
import { UpdateBusDto } from './dto/update-bus.dto';
import { CreateBusOwnerProfileDto } from './dto/bus-owner-profile.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../auth/guards/roles.guard';
import { Roles } from '../auth/decorators/roles.decorator';
import { CurrentUser } from '../auth/decorators/current-user.decorator';
import { UserDocument, UserRole } from '../schemas/user.schema';
import { BusStatus } from '../schemas/bus.schema';

@Controller('buses')
@UseGuards(JwtAuthGuard)
export class BusesController {
  constructor(private readonly busesService: BusesService) {}

  // Bus Owner Profile Endpoints
  @Post('owner/profile')
  @UseGuards(RolesGuard)
  @Roles(UserRole.BUS_OWNER)
  createBusOwnerProfile(
    @CurrentUser() user: UserDocument,
    @Body() createBusOwnerProfileDto: CreateBusOwnerProfileDto,
  ) {
    return this.busesService.createBusOwnerProfile(
      user._id.toString(),
      createBusOwnerProfileDto,
    );
  }

  @Get('owner/profile')
  @UseGuards(RolesGuard)
  @Roles(UserRole.BUS_OWNER, UserRole.ADMIN)
  getBusOwnerProfile(@CurrentUser() user: UserDocument) {
    return this.busesService.getBusOwnerProfile(user._id.toString());
  }

  @Patch('owner/profile/:id/approve')
  @UseGuards(RolesGuard)
  @Roles(UserRole.ADMIN)
  approveBusOwnerProfile(
    @Param('id') id: string,
    @CurrentUser() user: UserDocument,
  ) {
    return this.busesService.approveBusOwnerProfile(id, user._id.toString());
  }

  @Patch('owner/profile/:id/reject')
  @UseGuards(RolesGuard)
  @Roles(UserRole.ADMIN)
  rejectBusOwnerProfile(
    @Param('id') id: string,
    @CurrentUser() user: UserDocument,
    @Body('reason') reason: string,
  ) {
    return this.busesService.rejectBusOwnerProfile(
      id,
      user._id.toString(),
      reason,
    );
  }

  // Bus Management Endpoints
  @Post()
  @UseGuards(RolesGuard)
  @Roles(UserRole.BUS_OWNER)
  createBus(
    @CurrentUser() user: UserDocument,
    @Body() createBusDto: CreateBusDto,
  ) {
    return this.busesService.createBus(user._id.toString(), createBusDto);
  }

  @Get()
  findAllBuses(
    @CurrentUser() user: UserDocument,
    @Query('page', new ParseIntPipe({ optional: true })) page?: number,
    @Query('limit', new ParseIntPipe({ optional: true })) limit?: number,
    @Query('status') status?: BusStatus,
  ) {
    return this.busesService.findAllBuses(user, page, limit, status);
  }

  @Get(':id')
  findBusById(@Param('id') id: string, @CurrentUser() user: UserDocument) {
    return this.busesService.findBusById(id, user);
  }

  @Patch(':id')
  @UseGuards(RolesGuard)
  @Roles(UserRole.BUS_OWNER, UserRole.ADMIN)
  updateBus(
    @Param('id') id: string,
    @Body() updateBusDto: UpdateBusDto,
    @CurrentUser() user: UserDocument,
  ) {
    return this.busesService.updateBus(id, updateBusDto, user);
  }

  @Delete(':id')
  @UseGuards(RolesGuard)
  @Roles(UserRole.BUS_OWNER, UserRole.ADMIN)
  deleteBus(@Param('id') id: string, @CurrentUser() user: UserDocument) {
    return this.busesService.deleteBus(id, user);
  }

  @Patch(':id/seat-configuration')
  @UseGuards(RolesGuard)
  @Roles(UserRole.BUS_OWNER)
  updateSeatConfiguration(
    @Param('id') id: string,
    @Body() seatConfiguration: any,
    @CurrentUser() user: UserDocument,
  ) {
    return this.busesService.updateSeatConfiguration(
      id,
      seatConfiguration,
      user,
    );
  }

  @Get(':id/seat-map')
  async getSeatMap(@Param('id') id: string, @CurrentUser() user: UserDocument) {
    const bus = await this.busesService.findBusById(id, user);
    return {
      seatConfiguration: bus.seatConfiguration,
      totalSeats: bus.specifications.totalSeats,
    };
  }

  @Patch(':id/approve')
  @UseGuards(RolesGuard)
  @Roles(UserRole.ADMIN)
  approveBus(@Param('id') id: string, @CurrentUser() user: UserDocument) {
    return this.busesService.approveBus(id, user._id.toString());
  }

  @Patch(':id/reject')
  @UseGuards(RolesGuard)
  @Roles(UserRole.ADMIN)
  rejectBus(
    @Param('id') id: string,
    @CurrentUser() user: UserDocument,
    @Body('reason') reason: string,
  ) {
    return this.busesService.rejectBus(id, user._id.toString(), reason);
  }
}
</file>

<file path="src/buses/buses.module.ts">
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { BusesService } from './buses.service';
import { BusesController } from './buses.controller';
import { Bus, BusSchema } from '../schemas/bus.schema';
import {
  BusOwnerProfile,
  BusOwnerProfileSchema,
} from '../schemas/bus-owner-profile.schema';

@Module({
  imports: [
    MongooseModule.forFeature([
      { name: Bus.name, schema: BusSchema },
      { name: BusOwnerProfile.name, schema: BusOwnerProfileSchema },
    ]),
  ],
  controllers: [BusesController],
  providers: [BusesService],
  exports: [BusesService],
})
export class BusesModule {}
</file>

<file path="src/buses/buses.service.ts">
/* eslint-disable @typescript-eslint/no-unsafe-return */
/* eslint-disable @typescript-eslint/no-unsafe-call */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
import {
  Injectable,
  NotFoundException,
  ForbiddenException,
  ConflictException,
  BadRequestException,
} from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { Bus, BusDocument, BusStatus } from '../schemas/bus.schema';
import {
  BusOwnerProfile,
  BusOwnerProfileDocument,
  VerificationStatus,
} from '../schemas/bus-owner-profile.schema';
import { UserDocument, UserRole } from '../schemas/user.schema';
import { CreateBusDto } from './dto/create-bus.dto';
import { UpdateBusDto } from './dto/update-bus.dto';
import { CreateBusOwnerProfileDto } from './dto/bus-owner-profile.dto';

@Injectable()
export class BusesService {
  constructor(
    @InjectModel(Bus.name) private busModel: Model<BusDocument>,
    @InjectModel(BusOwnerProfile.name)
    private busOwnerProfileModel: Model<BusOwnerProfileDocument>,
  ) {}

  // Bus Owner Profile Management
  async createBusOwnerProfile(
    userId: string,
    createBusOwnerProfileDto: CreateBusOwnerProfileDto,
  ) {
    const existingProfile = await this.busOwnerProfileModel.findOne({
      userId: new Types.ObjectId(userId),
    });

    if (existingProfile) {
      throw new ConflictException('Bus owner profile already exists');
    }

    const profile = new this.busOwnerProfileModel({
      userId: new Types.ObjectId(userId),
      ...createBusOwnerProfileDto,
    });

    await profile.save();

    return {
      message: 'Bus owner profile created successfully',
      profile: profile.toObject(),
    };
  }

  async getBusOwnerProfile(userId: string) {
    const profile = await this.busOwnerProfileModel
      .findOne({ userId: new Types.ObjectId(userId) })
      .populate('userId', 'email profile')
      .populate('approvedBy', 'email profile.firstName profile.lastName');

    if (!profile) {
      throw new NotFoundException('Bus owner profile not found');
    }

    return profile;
  }

  async approveBusOwnerProfile(profileId: string, adminId: string) {
    const profile = await this.busOwnerProfileModel.findById(profileId);

    if (!profile) {
      throw new NotFoundException('Bus owner profile not found');
    }

    profile.verificationStatus = VerificationStatus.APPROVED;
    profile.approvedBy = new Types.ObjectId(adminId);
    await profile.save();

    return {
      message: 'Bus owner profile approved successfully',
      profile: profile.toObject(),
    };
  }

  async rejectBusOwnerProfile(
    profileId: string,
    adminId: string,
    reason: string,
  ) {
    const profile = await this.busOwnerProfileModel.findById(profileId);

    if (!profile) {
      throw new NotFoundException('Bus owner profile not found');
    }

    profile.verificationStatus = VerificationStatus.REJECTED;
    profile.approvedBy = new Types.ObjectId(adminId);
    profile.rejectionReason = reason;
    await profile.save();

    return {
      message: 'Bus owner profile rejected',
      profile: profile.toObject(),
    };
  }

  // Bus Management
  async createBus(ownerId: string, createBusDto: CreateBusDto) {
    // Check if bus owner profile is approved
    const ownerProfile = await this.busOwnerProfileModel.findOne({
      userId: new Types.ObjectId(ownerId),
    });

    if (!ownerProfile) {
      throw new BadRequestException('Bus owner profile not found');
    }

    if (ownerProfile.verificationStatus !== VerificationStatus.APPROVED) {
      throw new ForbiddenException(
        'Bus owner profile must be approved before registering buses',
      );
    }

    // Check if registration number already exists
    const existingBus = await this.busModel.findOne({
      registrationNumber: createBusDto.registrationNumber,
    });

    if (existingBus) {
      throw new ConflictException(
        'Bus with this registration number already exists',
      );
    }

    const bus = new this.busModel({
      ownerId: new Types.ObjectId(ownerId),
      ...createBusDto,
    });

    await bus.save();

    return {
      message: 'Bus registered successfully',
      bus: bus.toObject(),
    };
  }

  async findAllBuses(
    user: UserDocument,
    page: number = 1,
    limit: number = 10,
    status?: BusStatus,
  ) {
    const skip = (page - 1) * limit;
    const filter: any = {};

    // Role-based filtering
    if (user.role === UserRole.BUS_OWNER) {
      filter.ownerId = user._id;
    }

    if (status) {
      filter.status = status;
    }

    const [buses, total] = await Promise.all([
      this.busModel
        .find(filter)
        .populate('ownerId', 'email profile.firstName profile.lastName')
        .populate('approvedBy', 'email profile.firstName profile.lastName')
        .skip(skip)
        .limit(limit)
        .sort({ createdAt: -1 }),
      this.busModel.countDocuments(filter),
    ]);

    return {
      buses,
      pagination: {
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  async findBusById(id: string, user: UserDocument) {
    const bus = await this.busModel
      .findById(id)
      .populate('ownerId', 'email profile.firstName profile.lastName')
      .populate('approvedBy', 'email profile.firstName profile.lastName');

    if (!bus) {
      throw new NotFoundException('Bus not found');
    }

    // Check permissions
    if (
      user.role === UserRole.BUS_OWNER &&
      bus.ownerId._id.toString() !== user._id.toString()
    ) {
      throw new ForbiddenException('Access denied to this bus');
    }

    return bus;
  }

  async updateBus(id: string, updateBusDto: UpdateBusDto, user: UserDocument) {
    const bus = await this.findBusById(id, user);

    // Only bus owner can update their own buses (except status changes by admin)
    if (
      user.role === UserRole.BUS_OWNER &&
      bus.ownerId._id.toString() !== user._id.toString()
    ) {
      throw new ForbiddenException('Access denied to update this bus');
    }

    Object.assign(bus, updateBusDto);

    if (updateBusDto.status && user.role === UserRole.ADMIN) {
      if (updateBusDto.status === BusStatus.ACTIVE) {
        bus.approvedBy = user._id;
        bus.approvedAt = new Date();
      }
    }

    await bus.save();

    return {
      message: 'Bus updated successfully',
      bus: bus.toObject(),
    };
  }

  async deleteBus(id: string, user: UserDocument) {
    const bus = await this.findBusById(id, user);

    if (
      user.role === UserRole.BUS_OWNER &&
      bus.ownerId._id.toString() !== user._id.toString()
    ) {
      throw new ForbiddenException('Access denied to delete this bus');
    }

    await this.busModel.findByIdAndDelete(id);

    return { message: 'Bus deleted successfully' };
  }

  async updateSeatConfiguration(
    busId: string,
    seatConfiguration: any,
    user: UserDocument,
  ) {
    const bus = await this.findBusById(busId, user);

    if (
      user.role === UserRole.BUS_OWNER &&
      bus.ownerId._id.toString() !== user._id.toString()
    ) {
      throw new ForbiddenException('Access denied to update this bus');
    }

    bus.seatConfiguration = seatConfiguration;
    await bus.save();

    return {
      message: 'Seat configuration updated successfully',
      seatConfiguration: bus.seatConfiguration,
    };
  }

  async approveBus(id: string, adminId: string) {
    const bus = await this.busModel.findById(id);

    if (!bus) {
      throw new NotFoundException('Bus not found');
    }

    bus.status = BusStatus.ACTIVE;
    bus.approvedBy = new Types.ObjectId(adminId);
    bus.approvedAt = new Date();
    await bus.save();

    return {
      message: 'Bus approved successfully',
      bus: bus.toObject(),
    };
  }

  async rejectBus(id: string, adminId: string, reason: string) {
    const bus = await this.busModel.findById(id);

    if (!bus) {
      throw new NotFoundException('Bus not found');
    }

    bus.status = BusStatus.INACTIVE;
    bus.approvedBy = new Types.ObjectId(adminId);
    bus.rejectionReason = reason;
    await bus.save();

    return {
      message: 'Bus rejected',
      bus: bus.toObject(),
    };
  }
}
</file>

<file path="src/buses/dto/bus-owner-profile.dto.ts">
import {
  IsString,
  IsNotEmpty,
  IsOptional,
  ValidateNested,
  IsArray,
} from 'class-validator';
import { Type } from 'class-transformer';

export class BankDetailsDto {
  @IsString()
  @IsNotEmpty()
  bankName: string;

  @IsString()
  @IsNotEmpty()
  accountNumber: string;

  @IsString()
  @IsNotEmpty()
  accountHolderName: string;

  @IsString()
  @IsNotEmpty()
  branchCode: string;
}

export class CreateBusOwnerProfileDto {
  @IsString()
  @IsNotEmpty()
  businessName: string;

  @IsString()
  @IsNotEmpty()
  businessLicense: string;

  @IsString()
  @IsOptional()
  taxId?: string;

  @ValidateNested()
  @Type(() => BankDetailsDto)
  @IsOptional()
  bankDetails?: BankDetailsDto;

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  documents?: string[];
}

export class UpdateBusOwnerProfileDto {
  @IsString()
  @IsOptional()
  businessName?: string;

  @IsString()
  @IsOptional()
  businessLicense?: string;

  @IsString()
  @IsOptional()
  taxId?: string;

  @ValidateNested()
  @Type(() => BankDetailsDto)
  @IsOptional()
  bankDetails?: BankDetailsDto;

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  documents?: string[];
}
</file>

<file path="src/buses/dto/create-bus.dto.ts">
import {
  IsString,
  IsNotEmpty,
  IsEnum,
  IsNumber,
  IsArray,
  ValidateNested,
  IsOptional,
  Min,
  Max,
} from 'class-validator';
import { Type } from 'class-transformer';
import { BusType, SeatType } from '../../schemas/bus.schema';

export class BusDetailsDto {
  @IsString()
  @IsNotEmpty()
  make: string;

  @IsString()
  @IsNotEmpty()
  model: string;

  @IsNumber()
  @Min(1990)
  @Max(new Date().getFullYear() + 1)
  year: number;

  @IsString()
  @IsOptional()
  engineNumber?: string;

  @IsString()
  @IsOptional()
  chassisNumber?: string;
}

export class BusSpecificationsDto {
  @IsNumber()
  @Min(20)
  @Max(56)
  totalSeats: number;

  @IsEnum(BusType)
  busType: BusType;

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  facilities?: string[];
}

export class SeatPositionDto {
  @IsNumber()
  @Min(1)
  row: number;

  @IsNumber()
  @Min(1)
  column: number;
}

export class SeatConfigurationDto {
  @IsString()
  @IsNotEmpty()
  seatNumber: string;

  @ValidateNested()
  @Type(() => SeatPositionDto)
  position: SeatPositionDto;

  @IsEnum(SeatType)
  @IsOptional()
  type?: SeatType;

  @IsOptional()
  isActive?: boolean;

  @IsNumber()
  @Min(0.5)
  @Max(3.0)
  @IsOptional()
  priceMultiplier?: number;
}

export class BusLayoutDto {
  @IsString()
  @IsOptional()
  layoutType?: string;

  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => SeatConfigurationDto)
  seatMap: SeatConfigurationDto[];

  @IsNumber()
  @Min(1)
  totalRows: number;

  @IsNumber()
  @Min(2)
  @Max(6)
  seatsPerRow: number;

  @IsNumber()
  @Min(1)
  @IsOptional()
  aislePosition?: number;
}

export class CreateBusDto {
  @IsString()
  @IsNotEmpty()
  registrationNumber: string;

  @ValidateNested()
  @Type(() => BusDetailsDto)
  busDetails: BusDetailsDto;

  @ValidateNested()
  @Type(() => BusSpecificationsDto)
  specifications: BusSpecificationsDto;

  @ValidateNested()
  @Type(() => BusLayoutDto)
  seatConfiguration: BusLayoutDto;
}
</file>

<file path="src/buses/dto/update-bus.dto.ts">
import { PartialType } from '@nestjs/mapped-types';
import { CreateBusDto } from './create-bus.dto';
import { IsEnum, IsOptional, IsString } from 'class-validator';
import { BusStatus } from '../../schemas/bus.schema';

export class UpdateBusDto extends PartialType(CreateBusDto) {
  @IsEnum(BusStatus)
  @IsOptional()
  status?: BusStatus;

  @IsString()
  @IsOptional()
  rejectionReason?: string;
}
</file>

<file path="src/routes/dto/create-bus-route.dto.ts">
import {
  IsString,
  IsNotEmpty,
  IsNumber,
  IsArray,
  ValidateNested,
  IsBoolean,
  IsOptional,
  IsEnum,
  IsDateString,
  Min,
  Max,
  Matches,
} from 'class-validator';
import { Type } from 'class-transformer';
import { FrequencyType } from '../../schemas/bus-route.schema';

export class ScheduleDto {
  @IsString()
  @Matches(/^([01]?[0-9]|2[0-3]):[0-5][0-9]$/, {
    message: 'departureTime must be in HH:MM format',
  })
  departureTime: string;

  @IsString()
  @Matches(/^([01]?[0-9]|2[0-3]):[0-5][0-9]$/, {
    message: 'arrivalTime must be in HH:MM format',
  })
  arrivalTime: string;

  @IsEnum(FrequencyType)
  @IsOptional()
  frequency?: FrequencyType;

  @IsArray()
  @IsNumber({}, { each: true })
  @IsOptional()
  operatingDays?: number[];

  @IsDateString()
  effectiveFrom: string;

  @IsDateString()
  effectiveTo: string;
}

export class PricingDto {
  @IsNumber()
  @Min(0)
  baseFare: number;

  @IsNumber()
  @Min(0)
  @IsOptional()
  farePerKm?: number;

  @IsBoolean()
  @IsOptional()
  dynamicPricing?: boolean;

  @IsNumber()
  @Min(0.5)
  @Max(3.0)
  @IsOptional()
  peakHourMultiplier?: number;

  @IsNumber()
  @Min(0.5)
  @Max(3.0)
  @IsOptional()
  weekendMultiplier?: number;

  @IsNumber()
  @Min(0.5)
  @Max(3.0)
  @IsOptional()
  holidayMultiplier?: number;
}

export class DriverAssignmentDto {
  @IsString()
  @IsOptional()
  primaryDriver?: string;

  @IsString()
  @IsOptional()
  secondaryDriver?: string;

  @IsString()
  @IsOptional()
  conductor?: string;
}

export class CreateBusRouteDto {
  @IsString()
  @IsNotEmpty()
  busId: string;

  @IsString()
  @IsNotEmpty()
  routeId: string;

  @ValidateNested()
  @Type(() => ScheduleDto)
  schedule: ScheduleDto;

  @ValidateNested()
  @Type(() => PricingDto)
  pricing: PricingDto;

  @ValidateNested()
  @Type(() => DriverAssignmentDto)
  @IsOptional()
  driverAssignment?: DriverAssignmentDto;

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  specialNotes?: string[];
}
</file>

<file path="src/routes/dto/create-route.dto.ts">
import {
  IsString,
  IsNotEmpty,
  IsNumber,
  IsArray,
  ValidateNested,
  IsBoolean,
  IsOptional,
  Min,
  Max,
  Matches,
} from 'class-validator';
import { Type } from 'class-transformer';

export class LocationDto {
  @IsString()
  @IsNotEmpty()
  city: string;

  @IsString()
  @IsNotEmpty()
  station: string;

  @IsArray()
  @IsNumber({}, { each: true })
  coordinates: number[]; // [longitude, latitude]
}

export class IntermediateStopDto {
  @IsString()
  @IsNotEmpty()
  city: string;

  @IsString()
  @IsNotEmpty()
  station: string;

  @IsArray()
  @IsNumber({}, { each: true })
  coordinates: number[];

  @IsString()
  @Matches(/^([01]?[0-9]|2[0-3]):[0-5][0-9]$/, {
    message: 'arrivalTime must be in HH:MM format',
  })
  arrivalTime: string;

  @IsString()
  @Matches(/^([01]?[0-9]|2[0-3]):[0-5][0-9]$/, {
    message: 'departureTime must be in HH:MM format',
  })
  departureTime: string;

  @IsNumber()
  @Min(0)
  distanceFromOrigin: number;

  @IsNumber()
  @Min(0)
  fareFromOrigin: number;

  @IsNumber()
  @Min(5)
  @Max(60)
  @IsOptional()
  stopDuration?: number;
}

export class CreateRouteDto {
  @IsString()
  @IsNotEmpty()
  routeName: string;

  @ValidateNested()
  @Type(() => LocationDto)
  origin: LocationDto;

  @ValidateNested()
  @Type(() => LocationDto)
  destination: LocationDto;

  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => IntermediateStopDto)
  @IsOptional()
  intermediateStops?: IntermediateStopDto[];

  @IsNumber()
  @Min(1)
  totalDistance: number;

  @IsNumber()
  @Min(30)
  estimatedDuration: number;

  @IsBoolean()
  @IsOptional()
  isActive?: boolean;

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  popularTimes?: string[];

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  operatingDays?: string[];
}
</file>

<file path="src/routes/dto/update-bus-route.dto.ts">
import { PartialType } from '@nestjs/mapped-types';
import { CreateBusRouteDto } from './create-bus-route.dto';
import { IsEnum, IsOptional } from 'class-validator';
import { BusRouteStatus } from '../../schemas/bus-route.schema';

export class UpdateBusRouteDto extends PartialType(CreateBusRouteDto) {
  @IsEnum(BusRouteStatus)
  @IsOptional()
  status?: BusRouteStatus;
}
</file>

<file path="src/routes/dto/update-route.dto.ts">
import { PartialType } from '@nestjs/mapped-types';
import { CreateRouteDto } from './create-route.dto';

export class UpdateRouteDto extends PartialType(CreateRouteDto) {}
</file>

<file path="src/routes/routes.controller.ts">
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  UseGuards,
  Query,
  ParseIntPipe,
  ParseBoolPipe,
} from '@nestjs/common';
import { RoutesService } from './routes.service';
import { CreateRouteDto } from './dto/create-route.dto';
import { UpdateRouteDto } from './dto/update-route.dto';
import { CreateBusRouteDto } from './dto/create-bus-route.dto';
import { UpdateBusRouteDto } from './dto/update-bus-route.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../auth/guards/roles.guard';
import { Roles } from '../auth/decorators/roles.decorator';
import { CurrentUser } from '../auth/decorators/current-user.decorator';
import { UserDocument, UserRole } from '../schemas/user.schema';

@Controller('routes')
@UseGuards(JwtAuthGuard)
export class RoutesController {
  constructor(private readonly routesService: RoutesService) {}

  // Route Management
  @Post()
  @UseGuards(RolesGuard)
  @Roles(UserRole.ADMIN, UserRole.BUS_OWNER)
  createRoute(
    @Body() createRouteDto: CreateRouteDto,
    @CurrentUser() user: UserDocument,
  ) {
    return this.routesService.createRoute(createRouteDto, user);
  }

  @Get()
  findAllRoutes(
    @CurrentUser() user: UserDocument,
    @Query('page', new ParseIntPipe({ optional: true })) page?: number,
    @Query('limit', new ParseIntPipe({ optional: true })) limit?: number,
    @Query('search') search?: string,
    @Query('isActive', new ParseBoolPipe({ optional: true }))
    isActive?: boolean,
  ) {
    return this.routesService.findAllRoutes(
      user,
      page,
      limit,
      search,
      isActive,
    );
  }

  @Get('search')
  searchRoutes(
    @Query('origin') originCity: string,
    @Query('destination') destinationCity: string,
  ) {
    return this.routesService.searchRoutes(originCity, destinationCity);
  }

  @Get('popular')
  getPopularRoutes() {
    return this.routesService.getPopularRoutes();
  }

  @Get(':id')
  findRoute(@Param('id') id: string, @CurrentUser() user: UserDocument) {
    return this.routesService.findRouteById(id, user);
  }

  @Patch(':id')
  @UseGuards(RolesGuard)
  @Roles(UserRole.ADMIN, UserRole.BUS_OWNER)
  updateRoute(
    @Param('id') id: string,
    @Body() updateRouteDto: UpdateRouteDto,
    @CurrentUser() user: UserDocument,
  ) {
    return this.routesService.updateRoute(id, updateRouteDto, user);
  }

  @Delete(':id')
  @UseGuards(RolesGuard)
  @Roles(UserRole.ADMIN, UserRole.BUS_OWNER)
  deleteRoute(@Param('id') id: string, @CurrentUser() user: UserDocument) {
    return this.routesService.deleteRoute(id, user);
  }

  // Bus Route Assignment
  @Post('bus-assignments')
  @UseGuards(RolesGuard)
  @Roles(UserRole.ADMIN, UserRole.BUS_OWNER)
  assignBusToRoute(
    @Body() createBusRouteDto: CreateBusRouteDto,
    @CurrentUser() user: UserDocument,
  ) {
    return this.routesService.assignBusToRoute(createBusRouteDto, user);
  }

  @Get('bus-assignments/list')
  findBusRoutes(
    @CurrentUser() user: UserDocument,
    @Query('page', new ParseIntPipe({ optional: true })) page?: number,
    @Query('limit', new ParseIntPipe({ optional: true })) limit?: number,
    @Query('busId') busId?: string,
    @Query('routeId') routeId?: string,
  ) {
    return this.routesService.findBusRoutes(user, page, limit, busId, routeId);
  }

  @Get('bus-assignments/:id')
  findBusRoute(@Param('id') id: string, @CurrentUser() user: UserDocument) {
    return this.routesService.findBusRouteById(id, user);
  }

  @Patch('bus-assignments/:id')
  @UseGuards(RolesGuard)
  @Roles(UserRole.ADMIN, UserRole.BUS_OWNER)
  updateBusRoute(
    @Param('id') id: string,
    @Body() updateBusRouteDto: UpdateBusRouteDto,
    @CurrentUser() user: UserDocument,
  ) {
    return this.routesService.updateBusRoute(id, updateBusRouteDto, user);
  }

  @Delete('bus-assignments/:id')
  @UseGuards(RolesGuard)
  @Roles(UserRole.ADMIN, UserRole.BUS_OWNER)
  deleteBusRoute(@Param('id') id: string, @CurrentUser() user: UserDocument) {
    return this.routesService.deleteBusRoute(id, user);
  }
}
</file>

<file path="src/routes/routes.module.ts">
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { RoutesService } from './routes.service';
import { RoutesController } from './routes.controller';
import { Route, RouteSchema } from '../schemas/route.schema';
import { BusRoute, BusRouteSchema } from '../schemas/bus-route.schema';
import { Bus, BusSchema } from '../schemas/bus.schema';

@Module({
  imports: [
    MongooseModule.forFeature([
      { name: Route.name, schema: RouteSchema },
      { name: BusRoute.name, schema: BusRouteSchema },
      { name: Bus.name, schema: BusSchema },
    ]),
  ],
  controllers: [RoutesController],
  providers: [RoutesService],
  exports: [RoutesService],
})
export class RoutesModule {}
</file>

<file path="src/routes/routes.service.ts">
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
import {
  Injectable,
  NotFoundException,
  ForbiddenException,
  ConflictException,
  BadRequestException,
} from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { Route, RouteDocument } from '../schemas/route.schema';
import { BusRoute, BusRouteDocument } from '../schemas/bus-route.schema';
import { Bus, BusDocument } from '../schemas/bus.schema';
import { UserDocument, UserRole } from '../schemas/user.schema';
import { CreateRouteDto } from './dto/create-route.dto';
import { UpdateRouteDto } from './dto/update-route.dto';
import { CreateBusRouteDto } from './dto/create-bus-route.dto';
import { UpdateBusRouteDto } from './dto/update-bus-route.dto';

@Injectable()
export class RoutesService {
  constructor(
    @InjectModel(Route.name) private routeModel: Model<RouteDocument>,
    @InjectModel(BusRoute.name) private busRouteModel: Model<BusRouteDocument>,
    @InjectModel(Bus.name) private busModel: Model<BusDocument>,
  ) {}

  // Route Management
  async createRoute(createRouteDto: CreateRouteDto, user: UserDocument) {
    const route = new this.routeModel({
      ...createRouteDto,
      createdBy: user._id,
    });

    await route.save();

    return {
      message: 'Route created successfully',
      route: route.toObject(),
    };
  }

  async findAllRoutes(
    user: UserDocument,
    page: number = 1,
    limit: number = 10,
    search?: string,
    isActive?: boolean,
  ) {
    const skip = (page - 1) * limit;
    const filter: any = {};

    // Role-based filtering
    if (user.role === UserRole.BUS_OWNER) {
      filter.createdBy = user._id;
    }

    if (isActive !== undefined) {
      filter.isActive = isActive;
    }

    if (search) {
      filter.$or = [
        { routeName: { $regex: search, $options: 'i' } },
        { 'origin.city': { $regex: search, $options: 'i' } },
        { 'destination.city': { $regex: search, $options: 'i' } },
      ];
    }

    const [routes, total] = await Promise.all([
      this.routeModel
        .find(filter)
        .populate('createdBy', 'email profile.firstName profile.lastName')
        .skip(skip)
        .limit(limit)
        .sort({ createdAt: -1 }),
      this.routeModel.countDocuments(filter),
    ]);

    return {
      routes,
      pagination: {
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  async findRouteById(id: string, user: UserDocument) {
    const route = await this.routeModel
      .findById(id)
      .populate('createdBy', 'email profile.firstName profile.lastName');

    if (!route) {
      throw new NotFoundException('Route not found');
    }

    // Check permissions
    if (
      user.role === UserRole.BUS_OWNER &&
      route.createdBy._id.toString() !== user._id.toString()
    ) {
      throw new ForbiddenException('Access denied to this route');
    }

    return route;
  }

  async updateRoute(
    id: string,
    updateRouteDto: UpdateRouteDto,
    user: UserDocument,
  ) {
    const route = await this.findRouteById(id, user);

    if (
      user.role === UserRole.BUS_OWNER &&
      route.createdBy._id.toString() !== user._id.toString()
    ) {
      throw new ForbiddenException('Access denied to update this route');
    }

    Object.assign(route, updateRouteDto);
    await route.save();

    return {
      message: 'Route updated successfully',
      route: route.toObject(),
    };
  }

  async deleteRoute(id: string, user: UserDocument) {
    const route = await this.findRouteById(id, user);

    if (
      user.role === UserRole.BUS_OWNER &&
      route.createdBy._id.toString() !== user._id.toString()
    ) {
      throw new ForbiddenException('Access denied to delete this route');
    }

    // Check if route is assigned to any buses
    const busRoutes = await this.busRouteModel.find({ routeId: id });
    if (busRoutes.length > 0) {
      throw new BadRequestException(
        'Cannot delete route that is assigned to buses. Please remove bus assignments first.',
      );
    }

    await this.routeModel.findByIdAndDelete(id);

    return { message: 'Route deleted successfully' };
  }

  // Bus Route Assignment
  async assignBusToRoute(
    createBusRouteDto: CreateBusRouteDto,
    user: UserDocument,
  ) {
    const { busId, routeId } = createBusRouteDto;

    // Verify bus exists and user has permission
    const bus = await this.busModel.findById(busId);
    if (!bus) {
      throw new NotFoundException('Bus not found');
    }

    if (
      user.role === UserRole.BUS_OWNER &&
      bus.ownerId.toString() !== user._id.toString()
    ) {
      throw new ForbiddenException('Access denied to this bus');
    }

    // Verify route exists
    const route = await this.routeModel.findById(routeId);
    if (!route) {
      throw new NotFoundException('Route not found');
    }

    // Check if bus is already assigned to this route
    const existingAssignment = await this.busRouteModel.findOne({
      busId: new Types.ObjectId(busId),
      routeId: new Types.ObjectId(routeId),
    });

    if (existingAssignment) {
      throw new ConflictException('Bus is already assigned to this route');
    }

    // Convert driver IDs to ObjectIds
    const driverAssignment = createBusRouteDto.driverAssignment;
    if (driverAssignment) {
      if (driverAssignment.primaryDriver) {
        driverAssignment.primaryDriver = new Types.ObjectId(
          driverAssignment.primaryDriver,
        ) as any;
      }
      if (driverAssignment.secondaryDriver) {
        driverAssignment.secondaryDriver = new Types.ObjectId(
          driverAssignment.secondaryDriver,
        ) as any;
      }
      if (driverAssignment.conductor) {
        driverAssignment.conductor = new Types.ObjectId(
          driverAssignment.conductor,
        ) as any;
      }
    }

    const busRoute = new this.busRouteModel({
      busId: new Types.ObjectId(busId),
      routeId: new Types.ObjectId(routeId),
      schedule: createBusRouteDto.schedule,
      pricing: createBusRouteDto.pricing,
      driverAssignment,
      specialNotes: createBusRouteDto.specialNotes,
      createdBy: user._id,
    });

    await busRoute.save();

    return {
      message: 'Bus assigned to route successfully',
      busRoute: busRoute.toObject(),
    };
  }

  async findBusRoutes(
    user: UserDocument,
    page: number = 1,
    limit: number = 10,
    busId?: string,
    routeId?: string,
  ) {
    const skip = (page - 1) * limit;
    const filter: any = {};

    if (busId) {
      filter.busId = new Types.ObjectId(busId);
    }

    if (routeId) {
      filter.routeId = new Types.ObjectId(routeId);
    }

    // Role-based filtering
    if (user.role === UserRole.BUS_OWNER) {
      filter.createdBy = user._id;
    }

    const [busRoutes, total] = await Promise.all([
      this.busRouteModel
        .find(filter)
        .populate('busId', 'registrationNumber specifications')
        .populate('routeId', 'routeName origin destination')
        .populate('createdBy', 'email profile.firstName profile.lastName')
        .populate(
          'driverAssignment.primaryDriver',
          'email profile.firstName profile.lastName',
        )
        .populate(
          'driverAssignment.secondaryDriver',
          'email profile.firstName profile.lastName',
        )
        .populate(
          'driverAssignment.conductor',
          'email profile.firstName profile.lastName',
        )
        .skip(skip)
        .limit(limit)
        .sort({ createdAt: -1 }),
      this.busRouteModel.countDocuments(filter),
    ]);

    return {
      busRoutes,
      pagination: {
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  async findBusRouteById(id: string, user: UserDocument) {
    const busRoute = await this.busRouteModel
      .findById(id)
      .populate('busId', 'registrationNumber specifications')
      .populate('routeId', 'routeName origin destination intermediateStops')
      .populate('createdBy', 'email profile.firstName profile.lastName')
      .populate(
        'driverAssignment.primaryDriver',
        'email profile.firstName profile.lastName',
      )
      .populate(
        'driverAssignment.secondaryDriver',
        'email profile.firstName profile.lastName',
      )
      .populate(
        'driverAssignment.conductor',
        'email profile.firstName profile.lastName',
      );

    if (!busRoute) {
      throw new NotFoundException('Bus route assignment not found');
    }

    // Check permissions
    if (
      user.role === UserRole.BUS_OWNER &&
      busRoute.createdBy._id.toString() !== user._id.toString()
    ) {
      throw new ForbiddenException('Access denied to this bus route');
    }

    return busRoute;
  }

  async updateBusRoute(
    id: string,
    updateBusRouteDto: UpdateBusRouteDto,
    user: UserDocument,
  ) {
    const busRoute = await this.findBusRouteById(id, user);

    if (
      user.role === UserRole.BUS_OWNER &&
      busRoute.createdBy._id.toString() !== user._id.toString()
    ) {
      throw new ForbiddenException('Access denied to update this bus route');
    }

    Object.assign(busRoute, updateBusRouteDto);
    await busRoute.save();

    return {
      message: 'Bus route updated successfully',
      busRoute: busRoute.toObject(),
    };
  }

  async deleteBusRoute(id: string, user: UserDocument) {
    const busRoute = await this.findBusRouteById(id, user);

    if (
      user.role === UserRole.BUS_OWNER &&
      busRoute.createdBy._id.toString() !== user._id.toString()
    ) {
      throw new ForbiddenException('Access denied to delete this bus route');
    }

    await this.busRouteModel.findByIdAndDelete(id);

    return { message: 'Bus route assignment deleted successfully' };
  }

  // Search routes between cities
  async searchRoutes(originCity: string, destinationCity: string) {
    const routes = await this.routeModel.find({
      'origin.city': { $regex: originCity, $options: 'i' },
      'destination.city': { $regex: destinationCity, $options: 'i' },
      isActive: true,
    });

    return {
      routes,
      count: routes.length,
    };
  }

  // Get popular routes
  async getPopularRoutes() {
    const routes = await this.routeModel.aggregate([
      { $match: { isActive: true } },
      {
        $lookup: {
          from: 'busroutes',
          localField: '_id',
          foreignField: 'routeId',
          as: 'busAssignments',
        },
      },
      {
        $addFields: {
          busCount: { $size: '$busAssignments' },
        },
      },
      { $sort: { busCount: -1 } },
      { $limit: 10 },
    ]);

    return {
      routes,
      message: 'Popular routes retrieved successfully',
    };
  }
}
</file>

<file path="src/schemas/bus-owner-profile.schema.ts">
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

export type BusOwnerProfileDocument = BusOwnerProfile &
  Document & { _id: Types.ObjectId };

export enum VerificationStatus {
  PENDING = 'pending',
  APPROVED = 'approved',
  REJECTED = 'rejected',
}

@Schema({ timestamps: true })
export class BusOwnerProfile {
  @Prop({ type: Types.ObjectId, ref: 'User', required: true, unique: true })
  userId: Types.ObjectId;

  @Prop({ required: true })
  businessName: string;

  @Prop({ required: true })
  businessLicense: string;

  @Prop()
  taxId?: string;

  @Prop({
    type: {
      bankName: String,
      accountNumber: String,
      accountHolderName: String,
      branchCode: String,
    },
  })
  bankDetails?: {
    bankName: string;
    accountNumber: string;
    accountHolderName: string;
    branchCode: string;
  };

  @Prop({ type: [String], default: [] })
  documents: string[];

  @Prop({ enum: VerificationStatus, default: VerificationStatus.PENDING })
  verificationStatus: VerificationStatus;

  @Prop({ type: Types.ObjectId, ref: 'User' })
  approvedBy?: Types.ObjectId;

  @Prop()
  rejectionReason?: string;
}

export const BusOwnerProfileSchema =
  SchemaFactory.createForClass(BusOwnerProfile);

// Indexes
BusOwnerProfileSchema.index({ userId: 1 });
BusOwnerProfileSchema.index({ verificationStatus: 1 });
</file>

<file path="src/schemas/bus-route.schema.ts">
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

export type BusRouteDocument = BusRoute & Document & { _id: Types.ObjectId };

export enum FrequencyType {
  DAILY = 'daily',
  WEEKLY = 'weekly',
  CUSTOM = 'custom',
}

export enum BusRouteStatus {
  ACTIVE = 'active',
  SUSPENDED = 'suspended',
  MAINTENANCE = 'maintenance',
}

@Schema({ _id: false })
export class Schedule {
  @Prop({ required: true })
  departureTime: string; // "06:00"

  @Prop({ required: true })
  arrivalTime: string; // "12:00"

  @Prop({ enum: FrequencyType, default: FrequencyType.DAILY })
  frequency: FrequencyType;

  @Prop({ type: [Number], default: [1, 2, 3, 4, 5, 6, 0] }) // 0=Sunday, 1=Monday, etc.
  operatingDays: number[];

  @Prop({ required: true })
  effectiveFrom: Date;

  @Prop({ required: true })
  effectiveTo: Date;
}

@Schema({ _id: false })
export class Pricing {
  @Prop({ required: true })
  baseFare: number; // Base fare in LKR

  @Prop({ default: 2.5 })
  farePerKm: number; // Per km rate

  @Prop({ default: false })
  dynamicPricing: boolean;

  @Prop({ default: 1.0 })
  peakHourMultiplier: number;

  @Prop({ default: 1.0 })
  weekendMultiplier: number;

  @Prop({ default: 1.0 })
  holidayMultiplier: number;
}

@Schema({ _id: false })
export class DriverAssignment {
  @Prop({ type: Types.ObjectId, ref: 'User' })
  primaryDriver?: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'User' })
  secondaryDriver?: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'User' })
  conductor?: Types.ObjectId;
}

@Schema({ timestamps: true })
export class BusRoute {
  @Prop({ type: Types.ObjectId, ref: 'Bus', required: true })
  busId: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'Route', required: true })
  routeId: Types.ObjectId;

  @Prop({ type: Schedule, required: true })
  schedule: Schedule;

  @Prop({ type: Pricing, required: true })
  pricing: Pricing;

  @Prop({ type: DriverAssignment })
  driverAssignment?: DriverAssignment;

  @Prop({ enum: BusRouteStatus, default: BusRouteStatus.ACTIVE })
  status: BusRouteStatus;

  @Prop({ type: Types.ObjectId, ref: 'User', required: true })
  createdBy: Types.ObjectId;

  @Prop({ type: [String], default: [] })
  specialNotes: string[];
}

export const BusRouteSchema = SchemaFactory.createForClass(BusRoute);

// Indexes
BusRouteSchema.index({ busId: 1, routeId: 1 }, { unique: true });
BusRouteSchema.index({ routeId: 1 });
BusRouteSchema.index({ busId: 1 });
BusRouteSchema.index({ status: 1 });
BusRouteSchema.index({ createdBy: 1 });
</file>

<file path="src/schemas/bus.schema.ts">
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

export type BusDocument = Bus & Document & { _id: Types.ObjectId };

export enum BusType {
  AC = 'ac',
  NON_AC = 'non-ac',
  SEMI_LUXURY = 'semi-luxury',
  LUXURY = 'luxury',
}

export enum BusStatus {
  ACTIVE = 'active',
  INACTIVE = 'inactive',
  MAINTENANCE = 'maintenance',
  PENDING_APPROVAL = 'pending_approval',
}

export enum SeatType {
  REGULAR = 'regular',
  VIP = 'vip',
  LADIES = 'ladies',
  DISABLED = 'disabled',
}

@Schema({ _id: false })
export class SeatPosition {
  @Prop({ required: true })
  row: number;

  @Prop({ required: true })
  column: number;
}

@Schema({ _id: false })
export class SeatConfiguration {
  @Prop({ required: true })
  seatNumber: string;

  @Prop({ type: SeatPosition, required: true })
  position: SeatPosition;

  @Prop({ enum: SeatType, default: SeatType.REGULAR })
  type: SeatType;

  @Prop({ default: true })
  isActive: boolean;

  @Prop({ default: 1.0 })
  priceMultiplier: number;
}

@Schema({ _id: false })
export class BusLayout {
  @Prop({ default: '2x2' })
  layoutType: string;

  @Prop({ type: [SeatConfiguration], default: [] })
  seatMap: SeatConfiguration[];

  @Prop({ required: true })
  totalRows: number;

  @Prop({ required: true })
  seatsPerRow: number;

  @Prop({ default: 2 })
  aislePosition: number;
}

@Schema({ timestamps: true })
export class Bus {
  @Prop({ type: Types.ObjectId, ref: 'User', required: true })
  ownerId: Types.ObjectId;

  @Prop({ required: true, unique: true })
  registrationNumber: string;

  @Prop({
    type: {
      make: { type: String, required: true },
      model: { type: String, required: true },
      year: { type: Number, required: true },
      engineNumber: String,
      chassisNumber: String,
    },
    required: true,
  })
  busDetails: {
    make: string;
    model: string;
    year: number;
    engineNumber?: string;
    chassisNumber?: string;
  };

  @Prop({
    type: {
      totalSeats: { type: Number, required: true },
      busType: { type: String, enum: BusType, required: true },
      facilities: [String],
    },
    required: true,
  })
  specifications: {
    totalSeats: number;
    busType: BusType;
    facilities: string[];
  };

  @Prop({ type: BusLayout, required: true })
  seatConfiguration: BusLayout;

  @Prop({ type: [String], default: [] })
  documents: string[];

  @Prop({ type: [String], default: [] })
  images: string[];

  @Prop({ enum: BusStatus, default: BusStatus.PENDING_APPROVAL })
  status: BusStatus;

  @Prop({ type: Types.ObjectId, ref: 'User' })
  approvedBy?: Types.ObjectId;

  @Prop()
  approvedAt?: Date;

  @Prop()
  rejectionReason?: string;
}

export const BusSchema = SchemaFactory.createForClass(Bus);

// Indexes for better performance
BusSchema.index({ ownerId: 1 });
BusSchema.index({ registrationNumber: 1 });
BusSchema.index({ status: 1 });
BusSchema.index({ 'specifications.busType': 1 });
</file>

<file path="src/schemas/route.schema.ts">
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

export type RouteDocument = Route & Document & { _id: Types.ObjectId };

@Schema({ _id: false })
export class Location {
  @Prop({ required: true })
  city: string;

  @Prop({ required: true })
  station: string;

  @Prop({ type: [Number], required: true }) // [longitude, latitude]
  coordinates: number[];
}

@Schema({ _id: false })
export class IntermediateStop {
  @Prop({ required: true })
  city: string;

  @Prop({ required: true })
  station: string;

  @Prop({ type: [Number], required: true })
  coordinates: number[];

  @Prop({ required: true })
  arrivalTime: string; // "14:30"

  @Prop({ required: true })
  departureTime: string; // "14:45"

  @Prop({ required: true })
  distanceFromOrigin: number; // in km

  @Prop({ required: true })
  fareFromOrigin: number; // in LKR

  @Prop({ default: 10 })
  stopDuration: number; // in minutes
}

@Schema({ timestamps: true })
export class Route {
  @Prop({ required: true })
  routeName: string;

  @Prop({ type: Location, required: true })
  origin: Location;

  @Prop({ type: Location, required: true })
  destination: Location;

  @Prop({ type: [IntermediateStop], default: [] })
  intermediateStops: IntermediateStop[];

  @Prop({ required: true })
  totalDistance: number; // in km

  @Prop({ required: true })
  estimatedDuration: number; // in minutes

  @Prop({ default: true })
  isActive: boolean;

  @Prop({ type: Types.ObjectId, ref: 'User', required: true })
  createdBy: Types.ObjectId;

  @Prop({ type: [String], default: [] })
  popularTimes: string[]; // ["06:00", "18:00"]

  @Prop({ type: [String], default: [] })
  operatingDays: string[]; // ["monday", "tuesday", ...]
}

export const RouteSchema = SchemaFactory.createForClass(Route);

// Indexes for better performance
RouteSchema.index({ 'origin.city': 1, 'destination.city': 1 });
RouteSchema.index({ isActive: 1 });
RouteSchema.index({ createdBy: 1 });
RouteSchema.index({ routeName: 1 });
</file>

<file path="src/schemas/user.schema.ts">
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

export type UserDocument = User &
  Document & {
    _id: Types.ObjectId;
  };

export enum UserRole {
  ADMIN = 'admin',
  BUS_OWNER = 'bus_owner',
  DRIVER = 'driver',
  CONDUCTOR = 'conductor',
  PASSENGER = 'passenger',
}

export enum UserStatus {
  ACTIVE = 'active',
  SUSPENDED = 'suspended',
  PENDING = 'pending',
}

@Schema({ timestamps: true })
export class User {
  @Prop({ required: true, unique: true })
  email: string;

  @Prop({ required: true, select: false })
  password: string;

  @Prop({ required: true, enum: UserRole })
  role: UserRole;

  @Prop({
    type: {
      firstName: { type: String, required: true },
      lastName: { type: String, required: true },
      phone: { type: String, required: true },
      dateOfBirth: { type: Date },
      gender: { type: String, enum: ['male', 'female', 'other'] },
      address: {
        street: String,
        city: String,
        province: String,
        postalCode: String,
        country: { type: String, default: 'Sri Lanka' },
      },
      profilePicture: String,
    },
  })
  profile: {
    firstName: string;
    lastName: string;
    phone: string;
    dateOfBirth?: Date;
    gender?: string;
    address?: {
      street?: string;
      city?: string;
      province?: string;
      postalCode?: string;
      country?: string;
    };
    profilePicture?: string;
  };

  @Prop({
    type: {
      emailVerified: { type: Boolean, default: false },
      phoneVerified: { type: Boolean, default: false },
      documentsVerified: { type: Boolean, default: false },
    },
    default: {},
  })
  verification: {
    emailVerified: boolean;
    phoneVerified: boolean;
    documentsVerified: boolean;
  };

  @Prop({ enum: UserStatus, default: UserStatus.PENDING })
  status: UserStatus;

  @Prop({ select: false })
  refreshToken?: string;
}

export const UserSchema = SchemaFactory.createForClass(User);

// Index for better query performance
UserSchema.index({ email: 1 });
UserSchema.index({ role: 1 });
UserSchema.index({ status: 1 });
</file>

<file path="test/app.e2e-spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { App } from 'supertest/types';
import { AppModule } from './../src/app.module';

describe('AppController (e2e)', () => {
  let app: INestApplication<App>;

  beforeEach(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('/ (GET)', () => {
    return request(app.getHttpServer())
      .get('/')
      .expect(200)
      .expect('Hello World!');
  });
});
</file>

<file path="test/jest-e2e.json">
{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": ".",
  "testEnvironment": "node",
  "testRegex": ".e2e-spec.ts$",
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  }
}
</file>

<file path="src/main.ts">
import { NestFactory } from '@nestjs/core';
import { ValidationPipe } from '@nestjs/common';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // Enable CORS for your frontend
  app.enableCors({
    origin: ['http://localhost:3000'], // Your Next.js frontend URL
    credentials: true,
  });

  // Global validation pipe
  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      forbidNonWhitelisted: true,
      transform: true,
    }),
  );

  // Add global prefix
  app.setGlobalPrefix('api');

  const port = process.env.PORT ?? 3001;
  await app.listen(port);

  console.log(`🚀 Bus Management API running on: http://localhost:${port}/api`);
}
bootstrap();
</file>


<file path="src/app.module.ts">
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { MongooseModule } from '@nestjs/mongoose';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { AuthModule } from './auth/auth.module';
import { BusesModule } from './buses/buses.module';
import { RoutesModule } from './routes/routes.module'; // Add this import

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      envFilePath: '.env',
    }),
    MongooseModule.forRootAsync({
      useFactory: () => ({
        uri: process.env.MONGODB_URI,
        dbName: process.env.DATABASE_NAME,
      }),
    }),
    AuthModule,
    BusesModule,
    RoutesModule, // Add this line
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
</file>

</files>
